import { useCallback, useEffect, useMemo, useRef, useState } from "react";

const HOST = "https://api.exchangerate.host";
const TTL_MS = 15 * 60 * 1000; // 15 minutes

function ttlGet(key) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const { t, v } = JSON.parse(raw);
    if (Date.now() - t > TTL_MS) { localStorage.removeItem(key); return null; }
    return v;
  } catch { return null; }
}
function ttlSet(key, v) {
  try { localStorage.setItem(key, JSON.stringify({ t: Date.now(), v })); } catch {}
}

function useDebounced(value, ms = 250) {
  const [v, setV] = useState(value);
  useEffect(() => { const id = setTimeout(() => setV(value), ms); return () => clearTimeout(id); }, [value, ms]);
  return v;
}

export function useRates({ from, to, amount }) {
  // currencies
  const [currencies, setCurrencies] = useState([]);
  const [loadingCurrencies, setLoadingCurrencies] = useState(true);
  const [currencyError, setCurrencyError] = useState("");

  // single rate
  const [rate, setRate] = useState(null);
  const [rateDate, setRateDate] = useState("");
  const [rateError, setRateError] = useState("");
  const [loadingRate, setLoadingRate] = useState(false);

  // recent pairs
  const [recentPairs, setRecentPairs] = useState(() => {
    try { return JSON.parse(localStorage.getItem("recentPairs") || "[]"); } catch { return []; }
  });

  // ---- Load all symbols (cached) ----
  useEffect(() => {
    let alive = true;
    (async () => {
      setLoadingCurrencies(true);
      setCurrencyError("");

      const cached = ttlGet("symbols:v1");
      if (cached) {
        setCurrencies(cached);
        setLoadingCurrencies(false);
        return;
      }

      const ac = new AbortController();
      try {
        const res = await fetch(`${HOST}/symbols`, { signal: ac.signal });
        if (!res.ok) throw new Error(`Symbols HTTP ${res.status}`);
        const data = await res.json();
        if (!data?.symbols) throw new Error("Symbols payload missing");
        const list = Object.entries(data.symbols)
          .map(([code, obj]) => ({ code, name: obj.description || code }))
          .sort((a, b) => a.code.localeCompare(b.code));
        if (alive) {
          setCurrencies(list);
          ttlSet("symbols:v1", list);
        }
      } catch (e) {
        if (alive) {
          console.error("Symbols fetch failed:", e);
          setCurrencyError("Failed to load currency list. Please refresh.");
        }
      } finally {
        if (alive) setLoadingCurrencies(false);
      }
      return () => ac.abort();
    })();
    return () => { alive = false; };
  }, []);

  // ---- Track recent pairs ----
  useEffect(() => {
    const pair = `${from}->${to}`;
    if (!from || !to || from === to) return;
    setRecentPairs(prev => {
      const next = Array.from(new Set([pair, ...prev])).slice(0, 8);
      localStorage.setItem("recentPairs", JSON.stringify(next));
      return next;
    });
  }, [from, to]);

  // ---- Get single rate (with TTL + Abort + clear errors) ----
  const getRate = useCallback(async (f, t) => {
    if (!f || !t) throw new Error("Invalid pair");
    if (f === t) return { rate: 1, date: new Date().toISOString().slice(0,10) };

    const cacheKey = `rate:${f}->${t}`;
    const cached = ttlGet(cacheKey);
    if (cached) return cached;

    const ac = new AbortController();
    try {
      const url = `${HOST}/latest?base=${encodeURIComponent(f)}&symbols=${encodeURIComponent(t)}`;
      const res = await fetch(url, { signal: ac.signal, headers: { Accept: "application/json" } });
      if (!res.ok) throw new Error(`Rate HTTP ${res.status}`);
      const data = await res.json();
      const r = data?.rates?.[t];
      if (r == null) throw new Error("Rate missing in response");
      const value = { rate: r, date: data.date || new Date().toISOString().slice(0,10) };
      ttlSet(cacheKey, value);
      return value;
    } finally {
      ac.abort();
    }
  }, []);

  const refreshRate = useCallback(async () => {
    if (!from || !to) return;
    setRateError("");
    setLoadingRate(true);
    try {
      const { rate, date } = await getRate(from, to);
      setRate(rate);
      setRateDate(date);
    } catch (e) {
      console.error("Fetch rate failed:", e);
      setRateError(
        navigator.onLine
          ? "Could not load exchange rate. (Check console for details.)"
          : "You appear to be offline."
      );
      setRate(null);
      setRateDate("");
    } finally {
      setLoadingRate(false);
    }
  }, [from, to, getRate]);

  useEffect(() => { refreshRate(); }, [refreshRate]);

  // ---- Debounced conversion (no refetch on typing) ----
  const dAmount = useDebounced(amount, 200);
  const converted = useMemo(() => {
    const a = Number(dAmount);
    if (!Number.isFinite(a)) return 0;
    if (!rate) return from === to ? a : 0;
    return a * rate;
  }, [dAmount, rate, from, to]);

  // ---- All-rates (for multi-convert) ----
  const fetchAllRatesFrom = useCallback(async (base) => {
    if (!base) throw new Error("Base required");
    const cacheKey = `all:${base}`;
    const cached = ttlGet(cacheKey);
    if (cached) return cached;

    const ac = new AbortController();
    try {
      const res = await fetch(`${HOST}/latest?base=${encodeURIComponent(base)}`, {
        signal: ac.signal, headers: { Accept: "application/json" },
      });
      if (!res.ok) throw new Error(`All-rates HTTP ${res.status}`);
      const data = await res.json();
      const payload = { date: data.date || new Date().toISOString().slice(0,10), rates: data.rates || {} };
      ttlSet(cacheKey, payload);
      return payload;
    } finally {
      ac.abort();
    }
  }, []);

  return {
    currencies, loadingCurrencies, currencyError,
    rate, rateDate, rateError, loadingRate, converted,
    recentPairs,
    refreshRate, fetchAllRatesFrom,
  };
}
